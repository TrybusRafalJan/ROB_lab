% mainscript is rather short this time/////////////////////POCZĄTEK////////////////////////////% primary component countcomp_count = 40; %ilość cech w przestrzeni PCA[tvec tlab tstv tstl] = readSets(); % let's look at the first digit in the training setimshow(1-reshape(tvec(1,:), 28, 28)');% let's check labels in both sets[unique(tlab)'; unique(tstl)']% 9 labels in both data train and test datasets 0-9% compute and perform PCA transformation%zrzutowanie wszystkich wymiarów na jedną oś najlepiej reprzentującą dane[mu trmx] = prepTransform(tvec, comp_count);tvec = pcaTransform(tvec, mu, trmx);tstv = pcaTransform(tstv, mu, trmx);% let's shift labels by one to use labels directly as indicestlab += 1;tstl += 1;% To successfully prepare ensemble you have to implement perceptron function% I would use 10 first zeros and 10 fisrt ones % and only 2 first primary components% It'll allow printing of intermediate results in perceptron function%% YOUR CODE GOES HERE - testing of the perceptron function%tworzy macierz przejścia do przestzeni PCA (jedna oś najlepiej reprezentująca dane)liczbaCech = 2; %->2[mu trmx] = prepTransform(tvec,liczbaCech); %samo przejście do przestrzeni PCAtvec = pcaTransform(tvec, mu, trmx);%weźmy 0 oraz 1[unique(tlab)] %% ogólnie etykietyzeros_set = tvec(tlab(:,1) == 1,:);ones_set  = tvec(tlab(:,1) == 2,:);show = 10; %show n elementsones_set(1:show,1:liczbaCech)%obliczmy klasyfikator liniowy dla danych tej paryhpc = perceptron(zeros_set, ones_set);fx = [-hpc(2), -hpc(1)] / hpc(3);x = (-2:0.01:2)';a = fx(1);b = fx(2);%granica linowa y = ax+bgranica = [x, x .* a + b];plot = [ zeros(rows(zeros_set), 1), zeros_set; %klasa1	 ones(rows(ones_set), 1),   ones_set;		%klasa2	 ones(rows(granica), 1) .* 2, granica(:,:) ];	% granica liniowaplot2features(plot,2,3); %plot zbiorów i granicy//////////////////////////////////////////////////////////////////////// część OVO /////////////////////comp_count = 40; %ilość cech w przestrzeni PCA[tvec tlab tstv tstl] = readSets(); % let's look at the first digit in the training set% let's check labels in both sets[unique(tlab)'; unique(tstl)']% 9 labels in both data train and test datasets 0-9% compute and perform PCA transformation%zrzutowanie wszystkich wymiarów na jedną oś najlepiej reprzentującą dane[mu trmx] = prepTransform(tvec, comp_count);tvec = pcaTransform(tvec, mu, trmx);tstv = pcaTransform(tstv, mu, trmx);% let's shift labels by one to use labels directly as indicestlab += 1;tstl += 1;% training of the whole ensemble%trenuje zestaw klasyfikatorów liniowych 1vs1ovo = trainOVOensamble(tvec, tlab, @perceptron); %6k x 40 i 6k x 1% check your ensemble on train setclab = unamvoting(tvec, ovo); %klasyfikatory 1vs1 na treningowymcfmx = confMx(tlab, clab)compErrors(cfmx)% repeat on test setclab = unamvoting(tstv, ovo); %klasyfikatory 1vs1 na testowymcfmx = confMx(tstl, clab)compErrors(cfmx)////////////////////////////////////////////////////////////////////////////////////////////////OVR////////////////////////////////////////%% YOUR CODE GOES HERE%%%%% ZROBIŁEM OVAENSEMBLE GŁOSUJĄCY 1vsRest i tutaj wizualizacje dla klasy 0 vs rest%następnie policzyć dla wszystkich już z tym perceptronem%%początek ten samcomp_count = 40; %ilość cech w przestrzeni PCA[tvec tlab tstv tstl] = readSets(); % compute and perform PCA transformation%zrzutowanie wszystkich wymiarów na jedną oś najlepiej reprzentującą dane[mu trmx] = prepTransform(tvec, comp_count);tvec = pcaTransform(tvec, mu, trmx);tstv = pcaTransform(tstv, mu, trmx);% let's shift labels by one to use labels directly as indicestlab += 1;tstl += 1;zeros_set = tvec(tlab == 1,:);rest_set = tvec(tlab ~= 1,:);hpc2 = perceptron(zeros_set, rest_set);fx2 = [-hpc2(2), -hpc2(1)] / hpc2(3);x2 = (0:0.01:8)';a = fx2(1);b = fx2(2);%granica linowa y = ax+bgranica2 = [x2, x2 .* a + b];plot2 = [ zeros(rows(zeros_set), 1), zeros_set; %klasa1	 ones(rows(rest_set), 1),   rest_set;		%klasa2	 ones(rows(granica2), 1) .* 2, granica2(:,:) ];	% granica liniowaplot2features(plot2,2,3); %plot zbiorów i granicyovr = trainOVAensamble(tvec, tlab, @perceptron); %6k x 40 i 6k x 1% check your ensemble on train setclab = unamvoting(tvec, ovr); %klasyfikatory 1vs1 na treningowym cfmx = confMx(tlab, clab)compErrors(cfmx)% repeat on test setclab = unamvoting(tstv, ovr); %klasyfikatory 1vs1 na testowymcfmx = confMx(tstl, clab)compErrors(cfmx)////EXPANDED FEATURE////////////////comp_count = 40; %ilość cech w przestrzeni PCA[tvec tlab tstv tstl] = readSets(); % compute and perform PCA transformation%zrzutowanie wszystkich wymiarów na jedną oś najlepiej reprzentującą dane[mu trmx] = prepTransform(tvec, comp_count);tvec = pcaTransform(tvec, mu, trmx);tstv = pcaTransform(tstv, mu, trmx);% let's shift labels by one to use labels directly as indicestlab += 1;tstl += 1;expTVEC = expandFeatures(tvec);expTSTV =  expandFeatures(tstv);ovr = trainOVAensamble(expTVEC, tlab, @perceptron); %6k x 40 i 6k x 1% check your ensemble on train setclab = unamvoting(expTVEC, ovr); %klasyfikatory 1vs1 na treningowym cfmx = confMx(tlab, clab)compErrors(cfmx)% repeat on test setclab = unamvoting(expTSTV, ovr); %klasyfikatory 1vs1 na testowymcfmx = confMx(tstl, clab)compErrors(cfmx)ovo = trainOVOensamble(expTVEC, tlab, @perceptron); %6k x 40 i 6k x 1% check your ensemble on train setclab = unamvoting(expTVEC, ovo); %klasyfikatory 1vs1 na treningowym cfmx = confMx(tlab, clab)compErrors(cfmx)% repeat on test setclab = unamvoting(expTSTV, ovo); %klasyfikatory 1vs1 na testowymcfmx = confMx(tstl, clab)compErrors(cfmx)/////ULEPSZENIE//////// %ilość cech w przestrzeni PCA[tvec tlab tstv tstl] = readSets(); %wczytanie, pca, mniej danych, expandfeature, fld,train %tu% let's shift labels by one to use labels directly as indicestlab += 1;tstl += 1;[mu trmx] = prepTransform(tvec, 40);tvec = pcaTransform(tvec, mu, trmx);tstv = pcaTransform(tstv, mu, trmx);k = randperm(10000);tvec = tvec(k(1:10000),:);tlab = tlab(k(1:10000),:);expTVEC = expandFeatures(tvec);expTSTV =  expandFeatures(tstv);[sLDA WLDA M WPCA]=mylda(expTVEC,tlab,40);Y = expTVEC * WLDA;ovo = trainOVOensamble(Y, tlab, @perceptron); %6k x 40 i 6k x 1ovr = trainOVAensamble(Y, tlab, @perceptron); %6k x 40 i 6k x 1Z = expTSTV * WLDA;% check your ensemble on train setclab = unamvoting(Y, ovo); %klasyfikatory 1vs1 na treningowymcfmx = confMx(tlab, clab)compErrors(cfmx)% repeat on test setclab = unamvoting(Z, ovo); %klasyfikatory 1vs1 na testowymcfmx = confMx(tstl, clab)compErrors(cfmx)%endclab = unamvoting(Y, ovr); %klasyfikatory 1vs1 na treningowymcfmx = confMx(tlab, clab)compErrors(cfmx)% repeat on test setclab = unamvoting(Z, ovr); %klasyfikatory 1vs1 na testowymcfmx = confMx(tstl, clab)compErrors(cfmx)%end[tvec tlab tstv tstl] = readSets(); tlab += 1;tstl += 1;k = randperm(1037);tvec = tvec(k(1:10000),:);tlab = tlab(k(1:10000),:);[sLDA WLDA M WPCA]=mylda(expTVEC,tlab,80);Y = expTVEC * WLDA;ovo = trainOVOensamble(Y, tlab, @perceptron); %6k x 40 i 6k x 1% check your ensemble on train setclab = unamvoting(Y, ovo); %klasyfikatory 1vs1 na treningowymcfmx = confMx(tlab, clab)compErrors(cfmx)% repeat on test setclab = unamvoting(tstv, ovo); %klasyfikatory 1vs1 na testowymcfmx = confMx(tstl, clab)compErrors(cfmx)